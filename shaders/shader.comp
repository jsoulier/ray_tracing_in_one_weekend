#version 450

#include "config.h"
#include "random.glsl"

const float infinity = 3.402823466e+38;
const float pi = 3.1415926535897932385;
const float epsilon = 0.00000001f;

struct t_ray
{
    vec3 origin;
    vec3 direction;
};

struct t_hit
{
    float root;
    vec3 position;
    vec3 normal;
    vec3 albedo;
    uint scatter;
};

struct t_sphere
{
    vec3 center;
    float radius;
    vec3 albedo;
    uint scatter;
};

layout(local_size_x = THREADS) in;
layout(set = 0, binding = 0) readonly buffer t_spheres
{
    t_sphere b_spheres[];
};
layout(set = 1, binding = 0, rgba32f) writeonly uniform image2D i_image;
layout(set = 2, binding = 0) uniform t_num_spheres
{
    uint u_num_spheres;
};

const vec2 image_size = vec2(WIDTH, HEIGHT);
const vec2 viewport_size = image_size * VIEWPORT_SIZE;
const vec3 focal_length = vec3(0.0f, 0.0f, FOCAL_LENGTH);
const vec3 camera_center = vec3(0.0f, 0.0f, 0.0f);
const vec3 viewport_u = vec3(viewport_size.x, 0.0f, 0.0f);
const vec3 viewport_v = vec3(0.0f, -viewport_size.y, 0.0f);
const vec3 pixel_u = viewport_u / image_size.x;
const vec3 pixel_v = viewport_v / image_size.y;
const vec3 viewport_uv = camera_center - focal_length - (viewport_u + viewport_v) / 2.0f;
const vec3 pixel_00 = viewport_uv + 0.5f * (pixel_u + pixel_v);

bool hit_sphere(
    const in t_sphere sphere,
    const in t_ray ray,
    const in float ray_min,
    const in float ray_max,
    out t_hit hit)
{
    const vec3 offset = sphere.center - ray.origin;
    const float a = dot(ray.direction, ray.direction);
    const float b = dot(ray.direction, offset);
    const float c = dot(offset, offset) - pow(sphere.radius, 2);
    const float discriminant = b * b - a * c;
    if (discriminant < 0)
    {
        return false;
    }
    float root = (b - sqrt(discriminant)) / a;
    if (root <= ray_min || ray_max <= root)
    {
        root = (b + sqrt(discriminant)) / a;
        if (root <= ray_min || ray_max <= root)
        {
            return false;
        }
    }
    hit.root = root;
    hit.position = ray.origin + ray.direction * root;
    hit.normal = (hit.position - sphere.center) / sphere.radius;
    if (dot(ray.direction, hit.normal) >= 0)
    {
        hit.normal = -hit.normal;
    }
    hit.albedo = sphere.albedo;
    hit.scatter = sphere.scatter;
    return true;
}

vec3 get_bounce(
    const in t_ray ray,
    const in t_hit hit,
    const in uvec2 id,
    in uint iteration,
    const in uint depth)
{
    iteration += 1;
    for (uint i = 0;; i++)
    {
        switch (hit.scatter)
        {
        case LAMBERTIAN:
            {
                const float z = depth * DEPTH + i;
                vec3 vector;
                vector.x = random(vec4(id.x, id.y, z, iteration * 17), -1.0f, 1.0f);
                vector.y = random(vec4(id.x, id.y, z, iteration * 73), -1.0f, 1.0f);
                vector.z = random(vec4(id.x, id.y, z, iteration * 99), -1.0f, 1.0f);
                const float scalar = dot(vector, vector);
                if (scalar > epsilon && scalar <= 1.0f)
                {
                    vector /- sqrt(scalar);
                    vector += hit.normal;
                    if (dot(vector, vector) < epsilon)
                    {
                        vector = hit.normal;
                    }
                    return vector;
                }
                break;
            }
        case METAL:
            {
                return reflect(ray.direction, hit.normal);
            }
            break;
        }
    }
    return vec3(0.0f);
}

vec3 get_colour(
    const in uvec2 id,
    const in uint iteration,
    in t_ray ray)
{
    vec3 attenuation = vec3(1.0f);
    for (uint depth = 0; depth < DEPTH; depth++)
    {
        bool status = false;
        t_hit hit;
        float ray_min = 0.001f;
        float ray_max = infinity;
        for (uint i = 0; i < u_num_spheres; i++)
        {
            if (hit_sphere(b_spheres[i], ray, ray_min, ray_max, hit))
            {
                status = true;
                ray_max = hit.root;
            }
        }
        if (status)
        {
            const vec3 bounce = get_bounce(ray, hit, id, iteration, depth);
            ray = t_ray(hit.position, bounce);
            attenuation *= hit.albedo;
            continue;
        }
        const float a = 0.5f * (normalize(ray.direction).y + 1.0f);
        const vec3 sky = vec3(0.5f, 0.7f, 1.0f);
        const vec3 horizon = vec3(1.0f, 1.0f, 1.0f);
        const vec3 colour = (1.0f - a) * horizon + a * sky;
        return colour * attenuation;
    }
    return attenuation;
}

void main()
{
    const uvec2 size = imageSize(i_image);
    const uvec2 id = gl_GlobalInvocationID.xy;
    if (id.x >= size.x || id.y >= size.y)
    {
        return;
    }
    vec3 colour = vec3(0.0f);
    for (uint iteration = 0; iteration < SAMPLES; iteration++)
    {
        vec2 offset;
        offset.x = random(vec4(id.x, id.y, iteration, 0.0f)) - 0.5f;
        offset.y = random(vec4(id.x, id.y, iteration, 1.0f)) - 0.5f;
        const vec3 target = pixel_00 + ((id.x + offset.x) * pixel_u) + ((id.y + offset.y) * pixel_v);
        t_ray ray;
        ray.origin = vec3(0.0f, 0.0f, 0.0f);
        ray.direction = target - ray.origin;
        colour += get_colour(id, iteration, ray);
    }
    imageStore(i_image, ivec2(id.xy), vec4(sqrt(colour / SAMPLES), 1.0f));
}