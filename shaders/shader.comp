#version 450

#include "config.h"
#include "random.glsl"

const float infinity = 3.402823466e+38;
const float pi = 3.1415926535897932385;
const float phi = 1.61803398874989484820459;
const float epsilon = 0.00000001f;

struct t_sphere
{
    vec3 center;
    float radius;
};

struct t_ray
{
    vec3 origin;
    vec3 direction;
};

struct t_hit_record
{
    float root;
    vec3 position;
    vec3 normal;
};

layout(local_size_x = THREADS) in;
layout(set = 0, binding = 0) readonly buffer t_spheres
{
    t_sphere b_spheres[];
};
layout(set = 1, binding = 0, rgba32f) writeonly uniform image2D i_image;
layout(set = 2, binding = 0) uniform t_num_spheres
{
    uint u_num_spheres;
};

const float aspect_ratio = WIDTH / HEIGHT;
const vec2 image_size = vec2(WIDTH, HEIGHT);
const vec2 viewport_size = image_size * VIEWPORT_SIZE;
const vec3 camera_center = vec3(0.0f, 0.0f, 0.0f);
const vec3 viewport_u = vec3(viewport_size.x, 0.0f, 0.0f);
const vec3 viewport_v = vec3(0.0f, -viewport_size.y, 0.0f);
const vec3 pixel_delta_u = viewport_u / image_size.x;
const vec3 pixel_delta_v = viewport_v / image_size.y;
const vec3 viewport_uv = camera_center - vec3(0.0f, 0.0f, FOCAL_LENGTH) - viewport_u / 2.0f - viewport_v / 2.0f;
const vec3 pixel00 = viewport_uv + 0.5f * (pixel_delta_u + pixel_delta_v);

void get_ray(
    const in uvec2 id,
    const in uint i,
    out t_ray ray)
{
    vec2 offset;
    offset.x = random(vec4(id.x, id.y, i, 0.0f)) - 0.5f;
    offset.y = random(vec4(id.x, id.y, i, 1.0f)) - 0.5f;
    vec3 pixel_sample = pixel00 + ((float(id.x) + offset.x) * pixel_delta_u) + ((float(id.y) + offset.y) * pixel_delta_v);
    ray.origin = vec3(0.0f, 0.0f, 0.0f);
    ray.direction = pixel_sample - ray.origin;
    // ray.direction = vec3(0.0f);
    // ray.direction.x = random(vec4(id.x, id.y, i, 0.0f)) * 0.5 + 0.5;
    // ray.direction.y = random(vec4(id.x, id.y, i, 1.0f)) * 0.5 + 0.5;
}

vec3 random_unit_vector(
    const in uvec2 id,
    const in uint bounce,
    const in uint s)
{
    for (uint i = 0;; i++)
    {
        vec3 vector;
        vector.x = random(vec4(id.x, id.y, i + bounce * DEPTH, 13 * (s + 1)), -1.0f, 1.0f);
        vector.y = random(vec4(-float(id.x), id.y, i + bounce * DEPTH, 79 * (s + 1)), -1.0f, 1.0f);
        vector.z = random(vec4(id.x, -float(id.y), i + bounce * DEPTH, 133 * (s + 1)), -1.0f, 1.0f);
        const float scalar = dot(vector, vector);
        if (epsilon < scalar && scalar <= 1.0f)
        {
            return vector / sqrt(scalar);
        }
    }
}

vec3 random_on_hemisphere(
    const in uvec2 id,
    const in vec3 normal,
    const in uint bounce,
    const in uint s)
{
    vec3 on_unit_sphere = random_unit_vector(id, bounce, s);
    if (dot(on_unit_sphere, normal) > 0.0)
    {
        return on_unit_sphere;
    }
    else
    {
        return -on_unit_sphere;
    }
}

bool test_sphere(
    const in t_sphere sphere,
    const in t_ray ray,
    const in float ray_min,
    const in float ray_max,
    out t_hit_record record)
{
    const vec3 offset = sphere.center - ray.origin;
    const float a = dot(ray.direction, ray.direction);
    const float b = dot(ray.direction, offset);
    const float c = dot(offset, offset) - pow(sphere.radius, 2);
    const float discriminant = b * b - a * c;
    if (discriminant < 0)
    {
        return false;
    }
    float root = (b - sqrt(discriminant)) / a;
    if (root <= ray_min || ray_max <= root)
    {
        root = (b + sqrt(discriminant)) / a;
        if (root <= ray_min || ray_max <= root)
        {
            return false;
        }
    }
    record.root = root;
    record.position = ray.origin + ray.direction * root;
    record.normal = (record.position - sphere.center) / sphere.radius;
    if (dot(ray.direction, record.normal) >= 0)
    {
        record.normal = -record.normal;
    }
    return true;
}

bool test(
    const in t_ray ray,
    const float ray_min,
    const float ray_max,
    out t_hit_record record)
{
    bool hit = false;
    float closest = ray_max;
    for (uint i = 0; i < u_num_spheres; i++)
    {
        if (test_sphere(b_spheres[i], ray, ray_min, closest, record))
        {
            hit = true;
            closest = record.root;
        }
    }
    return hit;
}

vec3 ray_color(
    const in uvec2 id,
    const in t_ray initial_ray,
    const in uint s)
{
    float attenuation = 0.5f;
    t_ray ray = initial_ray;
    for (int depth = 0; depth < 50; depth++)
    {
        t_hit_record record;
        if (test(ray, 0.001f, infinity, record))
        {
            vec3 dir = random_on_hemisphere(id, record.normal, depth, s);
            ray = t_ray(record.position, dir);
            attenuation *= 0.5f;
            continue;
        }
        else
        {
            const vec3 vector = normalize(ray.direction);
            const float a = 0.5f * (vector.y + 1.0f);
            vec3 background = (1.0f - a) * vec3(1.0f, 1.0f, 1.0f) + a * vec3(0.5f, 0.7f, 1.0f);
            return (attenuation * 2.0f) * background;
        }
    }
    return vec3(0.0f);
}

void main()
{
    const uvec2 size = imageSize(i_image);
    const uvec2 id = gl_GlobalInvocationID.xy;
    if (id.x >= size.x || id.y >= size.y)
    {
        return;
    }
    const vec3 pixel_center = pixel00 + id.x * pixel_delta_u + id.y * pixel_delta_v;
    const vec3 ray_direction = pixel_center - camera_center;
    vec3 color = vec3(0.0f);
    // t_ray ray;
    // get_ray(id, 1, ray);
    // imageStore(i_image, ivec2(id.xy), vec4(ray.direction, 1.0f));
    for (uint i = 0; i < SAMPLES; i++)
    {
        t_ray ray;
        get_ray(id, i, ray);
        color += ray_color(id, ray, i);
    }
    imageStore(i_image, ivec2(id.xy), vec4(color / SAMPLES, 1.0f));
}