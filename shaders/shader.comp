#version 450

#include "config.h"
#include "random.glsl"

const float infinity = 3.402823466e+38;
const float pi = 3.1415926535897932385;
const float epsilon = 0.00000001f;

struct t_ray
{
    vec3 origin;
    vec3 direction;
};

struct t_material
{
    vec3 albedo;
    uint type;
    float fuzz;
    float refraction;
    uint padding1;
    uint padding2;
};

struct t_hit
{
    float offset;
    vec3 position;
    vec3 normal;
    bool side;
    t_material material;
};

struct t_sphere
{
    vec3 position;
    float radius;
    t_material material;
};

layout(local_size_x = THREADS) in;
layout(set = 0, binding = 0) readonly buffer t_spheres
{
    t_sphere b_spheres[];
};
layout(set = 1, binding = 0, rgba32f) uniform image2D i_image;
layout(set = 2, binding = 0) uniform t_num_spheres
{
    uint u_num_spheres;
};
layout(set = 2, binding = 1) uniform t_batch
{
    uint u_batch;
};

bool hit_sphere(
    const in t_sphere sphere,
    const in t_ray ray,
    const in float ray_min,
    const in float ray_max,
    out t_hit hit)
{
    const vec3 offset = sphere.position - ray.origin;
    const float a = dot(ray.direction, ray.direction);
    const float b = dot(ray.direction, offset);
    const float c = dot(offset, offset) - pow(sphere.radius, 2);
    const float discriminant = b * b - a * c;
    if (discriminant < 0)
    {
        return false;
    }
    float root = (b - sqrt(discriminant)) / a;
    if (root <= ray_min || ray_max <= root)
    {
        root = (b + sqrt(discriminant)) / a;
        if (root <= ray_min || ray_max <= root)
        {
            return false;
        }
    }
    hit.offset = root;
    hit.position = ray.origin + ray.direction * root;
    hit.normal = (hit.position - sphere.position) / sphere.radius;
    hit.side = dot(ray.direction, hit.normal) < 0;
    if (!hit.side)
    {
        hit.normal = -hit.normal;
    }
    hit.material = sphere.material;
    return true;
}

bool get_bounce(
    const in t_ray ray,
    const in t_hit hit,
    const in uvec2 id,
    const in uint count,
    const in uint depth,
    out vec3 bounce,
    out vec3 colour)
{
    switch (hit.material.type)
    {
    case LAMBERTIAN:
        {
            bounce = random3(id, count, depth) + hit.normal;
            if (dot(bounce, bounce) < epsilon)
            {
                bounce = hit.normal;
            }
            colour = hit.material.albedo;
            return true;
        }
        break;
    case METAL:
        {
            bounce = normalize(reflect(ray.direction, hit.normal));
            bounce += random3(id, count, depth) * hit.material.fuzz;
            colour = hit.material.albedo;
            return dot(bounce, hit.normal) > 0;
        }
        break;
    case DIAELECTRIC:
        {
            float ri;
            if (hit.side)
            {
                ri = 1.0f / hit.material.refraction;
            }
            else
            {
                ri = hit.material.refraction;
            }
            vec3 dir = normalize(ray.direction);
            float cos_theta = min(dot(-dir, hit.normal), 1.0f);
            float sin_theta = sqrt(1.0f - pow(cos_theta, 2));
            bool cannot_refract = ri * sin_theta > 1.0f;
            float r0 = (1.0f - hit.material.refraction) / (1.0f + hit.material.refraction);
            r0 = pow(r0, 2);
            const float reflectance = r0 + (1.0f - r0) * pow(1.0f - cos_theta, 5);
            if (cannot_refract || reflectance > random(vec2(id.x * WIDTH + depth, id.y * HEIGHT + count)))
            {
                bounce = reflect(dir, hit.normal);
            }
            else
            {
                bounce = refract(dir, hit.normal, ri);
            }
            colour = vec3(1.0f);
            return true;
        }
        break;
    }
    return false;
}

vec3 get_colour(
    const in uvec2 id,
    const in uint count,
    in t_ray ray)
{
    vec3 attenuation = vec3(1.0f);
    for (uint depth = 0; depth < DEPTH; depth++)
    {
        t_hit hit;
        float a = 0.001f;
        float b = infinity;
        bool status = false;
        for (uint i = 0; i < u_num_spheres; i++)
        {
            if (hit_sphere(b_spheres[i], ray, a, b, hit))
            {
                status = true;
                b = hit.offset;
            }
        }
        if (status)
        {
            vec3 bounce;
            vec3 colour;
            if (!get_bounce(ray, hit, id, count, depth, bounce, colour))
            {
                colour = vec3(0.0f);
            }
            ray = t_ray(hit.position, bounce);
            attenuation *= colour;
            continue;
        }
        const float c = 0.5f * (normalize(ray.direction).y + 1.0f);
        const vec3 sky = vec3(0.5f, 0.7f, 1.0f);
        const vec3 horizon = vec3(1.0f, 1.0f, 1.0f);
        const vec3 colour = (1.0f - c) * horizon + c * sky;
        return attenuation * colour;
    }
    return attenuation;
}

void main()
{
    const uvec2 size = imageSize(i_image);
    const uvec2 id = gl_GlobalInvocationID.xy;
    if (id.x >= size.x || id.y >= size.y)
    {
        return;
    }
    const vec2 image_size = vec2(WIDTH, HEIGHT);
    const float viewport_h = 2.0f * tan(radians(FOV / 2.0f)) * FOCUS_LENGTH;
    const float viewport_w = viewport_h * image_size.x / image_size.y;
    const vec3 vector_w = normalize(SOURCE - TARGET);
    const vec3 vector_u = normalize(cross(UP, vector_w));
    const vec3 vector_v = cross(vector_w, vector_u);
    const vec3 viewport_u = viewport_w * vector_u;
    const vec3 viewport_v = viewport_h * -vector_v;
    const vec3 pixel_u = viewport_u / image_size.x;
    const vec3 pixel_v = viewport_v / image_size.y;
    const vec3 viewport_uv = SOURCE - FOCUS_LENGTH * vector_w - (viewport_u + viewport_v) / 2.0f;
    const vec3 pixel_00 = viewport_uv + (pixel_u + pixel_v) / 2.0f;
    const float defocus_radius = FOCUS_LENGTH * tan(radians(DEFOCUS_ANGLE / 2.0f));
    const vec3 defocus_u = vector_u * defocus_radius;
    const vec3 defocus_v = vector_v * defocus_radius;
    vec3 colour = vec3(0.0f);
    for (uint count = 0; count < SAMPLES / BATCHES; count++)
    {
        const vec2 offset = random2(id, count) - 0.5f;
        const vec3 target = pixel_00 + ((id.x + offset.x) * pixel_u) + ((id.y + offset.y) * pixel_v);
        t_ray ray;
        for (uint i = 0; i < 10; i++)
        {
            ray.origin.xy = random2(id, count, i);
            if (dot(ray.origin.xy, ray.origin.xy) < 1.0f)
            {
                break;
            }
        }
        ray.origin = SOURCE + (ray.origin.x * defocus_u) + (ray.origin.y * defocus_v);
        ray.direction = target - ray.origin;
        colour += get_colour(id, count, ray);
    }
    vec3 previous;
    if (u_batch > 0)
    {
        previous = imageLoad(i_image, ivec2(id.xy)).xyz;
    }
    else
    {
        previous = vec3(0.0f);
    }
    colour = colour / (SAMPLES / BATCHES);
    imageStore(i_image, ivec2(id.xy), vec4(previous + colour, 1.0f));
}