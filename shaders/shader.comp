#version 450

#include "config.h"

struct t_sphere
{
    vec3 center;
    float radius;
};

struct t_ray
{
    vec3 origin;
    vec3 direction;
};

layout(local_size_x = THREADS) in;
layout(set = 0, binding = 0) readonly buffer t_spheres
{
    t_sphere b_spheres[];
};
layout(set = 1, binding = 0, rgba32f) writeonly uniform image2D i_image;
layout(set = 2, binding = 0) uniform t_num_spheres
{
    uint u_num_spheres;
};

const float aspect_ratio = WIDTH / HEIGHT;
const vec2 image_size = vec2(WIDTH, HEIGHT);
const vec2 viewport_size = image_size * VIEWPORT_SIZE;
const vec3 camera_center = vec3(0.0f, 0.0f, 0.0f);
const vec3 viewport_u = vec3(viewport_size.x, 0.0f, 0.0f);
const vec3 viewport_v = vec3(0.0f, -viewport_size.y, 0.0f);
const vec3 pixel_delta_u = viewport_u / image_size.x;
const vec3 pixel_delta_v = viewport_v / image_size.y;
const vec3 viewport_uv = camera_center - vec3(0.0f, 0.0f, FOCAL_LENGTH) - viewport_u / 2.0f - viewport_v / 2.0f;
const vec3 pixel00 = viewport_uv + 0.5f * (pixel_delta_u + pixel_delta_v);

float test_sphere(
    const in t_sphere sphere,
    const in t_ray ray)
{
    const vec3 offset = sphere.center - ray.origin;
    const float a = dot(ray.direction, ray.direction);
    const float b = dot(ray.direction, offset);
    const float c = dot(offset, offset) - pow(sphere.radius, 2);
    const float discriminant = b * b - a * c;
    if (discriminant < 0)
    {
        return -1.0f;
    }
    else
    {
        return (b - sqrt(discriminant)) / a;
    }
}

vec3 ray_color(
    const in t_ray ray)
{
    t_sphere sphere;
    sphere.center = vec3(0.0f, 0.0f, -1.0f);
    sphere.radius = 0.5f;
    const float t = test_sphere(sphere, ray);
    if (t > 0.0f)
    {
        vec3 n = normalize(ray.origin + ray.direction * t - vec3(0, 0, -1));
        return 0.5 * vec3(n.x + 1, n.y + 1, n.z + 1);
    }
    const vec3 vector = normalize(ray.direction);
    const float a = 0.5f * (vector.y + 1.0f);
    return (1.0f - a) * vec3(1.0f, 1.0f, 1.0f) + a * vec3(0.5f, 0.7f, 1.0f);
}

void main()
{
    const uvec2 size = imageSize(i_image);
    const uvec2 id = gl_GlobalInvocationID.xy;
    if (id.x >= size.x || id.y >= size.y)
    {
        return;
    }
    const vec3 pixel_center = pixel00 + id.x * pixel_delta_u + id.y * pixel_delta_v;
    const vec3 ray_direction = pixel_center - camera_center;
    t_ray ray;
    ray.origin = camera_center;
    ray.direction = ray_direction;
    imageStore(i_image, ivec2(id.xy), vec4(ray_color(ray), 1.0f));
}