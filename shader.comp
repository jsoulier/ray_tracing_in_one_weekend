#include "config.h"
#include "random.hlsl"

struct Ray
{
    float3 Origin;
    float3 Direction;
};

struct Material
{
    float3 Albedo;
    uint Padding1;
    uint Type;
    float Fuzz;
    float Refraction;
    uint Padding2;
};

struct Hit
{
    float Offset;
    float3 Position;
    float3 Normal;
    bool Face;
    Material Material;
};

struct Sphere
{
    float3 Position;
    float Radius;
    Material Material;
};

cbuffer UniformBuffer : register(b0, space2)
{
    uint NumSpheres;
};

cbuffer UniformBuffer : register(b1, space2)
{
    uint Batch;
};

StructuredBuffer<Sphere> spheres : register(t0, space0);
[[vk::image_format("rgba32f")]]
RWTexture2D<float4> image1 : register(u0, space1);
[[vk::image_format("rgba32f")]]
RWTexture2D<float4> image2 : register(u1, space1);

bool HitSphere(
    const in Sphere sphere,
    const in Ray ray,
    const in float near,
    const in float far,
    out Hit hit)
{
    const float3 offset = sphere.Position - ray.Origin;
    const float a = dot(ray.Direction, ray.Direction);
    const float b = dot(ray.Direction, offset);
    const float c = dot(offset, offset) - pow(sphere.Radius, 2);
    const float discriminant = b * b - a * c;
    if (discriminant < 0.0f)
    {
        return false;
    }
    float root = (b - sqrt(discriminant)) / a;
    if (root <= near || far <= root)
    {
        root = (b + sqrt(discriminant)) / a;
        if (root <= near || far <= root)
        {
            return false;
        }
    }
    hit.Offset = root;
    hit.Position = ray.Origin + ray.Direction * root;
    hit.Normal = (hit.Position - sphere.Position) / sphere.Radius;
    hit.Face = dot(ray.Direction, hit.Normal) < 0.0f;
    if (!hit.Face)
    {
        hit.Normal = -hit.Normal;
    }
    hit.Material = sphere.Material;
    return true;
}

bool GetBounce(
    const in Ray ray,
    const in Hit hit,
    const in uint2 id,
    const in uint count,
    const in uint depth,
    out float3 bounce,
    out float3 colour)
{
    switch (hit.Material.Type)
    {
    case LAMBERTIAN:
        bounce = Random(id, count, depth).xyz + hit.Normal;
        bounce = dot(bounce, bounce) < 0.001f ? hit.Normal : bounce;
        colour = hit.Material.Albedo;
        return true;
    case METAL:
        bounce = normalize(reflect(ray.Direction, hit.Normal));
        bounce += Random(id, count, depth).xyz * hit.Material.Fuzz;
        colour = hit.Material.Albedo;
        return dot(bounce, hit.Normal) > 0.0f;
    case DIAELECTRIC:
        colour = 1.0f;
        const float m = hit.Material.Refraction;
        float ri;
        if (hit.Face)
        {
            ri = 1.0f / m;
        }
        else
        {
            ri = m;
        }
        const float3 vector = normalize(ray.Direction);
        const float c = min(dot(-vector, hit.Normal), 1.0f);
        const float s = sqrt(1.0f - pow(c, 2));
        const float r = pow((1.0f - m) / (1.0f + m), 2);
        if (ri * s > 1.0f)
        {
            bounce = reflect(vector, hit.Normal);
            return true;
        }
        const float reflectance = r + (1.0f - r) * pow(1.0f - c, 5);
        const float2 size = float2(WIDTH, HEIGHT);
        if (reflectance > Random(id * size + float2(depth, count)))
        {
            bounce = reflect(vector, hit.Normal);
        }
        else
        {
            bounce = refract(vector, hit.Normal, ri);
        }
        return true;
    }
    return false;
}

[numthreads(THREADS, 1, 1)]
void main(uint3 globalInvocationID : SV_DispatchThreadID)
{
    uint width;
    uint height;
    image1.GetDimensions(width, height);
    const uint2 size = uint2(width, height);
    const uint2 id = globalInvocationID.xy;
    if (id.x >= size.x || id.y >= size.y)
    {
        return;
    }
    const float3 vectorW = normalize(SOURCE - TARGET);
    const float3 vectorU = normalize(cross(UP, vectorW));
    const float3 vectorV = cross(vectorW, vectorU);
    const float viewportH = 2.0f * tan(radians(FOV / 2.0f)) * FOCUS;
    const float viewportW = viewportH * size.x / size.y;
    const float oof = FOCUS * tan(radians(OOF / 2.0f));
    const float3 viewportU = viewportW * vectorU;
    const float3 viewportV = viewportH * -vectorV;
    const float3 pixelU = viewportU / size.x;
    const float3 pixelV = viewportV / size.y;
    const float3 pixel0 = 
        SOURCE -
        FOCUS * vectorW -
        viewportU / 2.0f -
        viewportV / 2.0f +
        pixelU / 2.0f +
        pixelV / 2.0f;
    float3 colour = 0.0f;
    const uint samples = SAMPLES / BATCHES;
    const uint start = Batch * samples;
    for (uint count = start; count < start + samples; count++)
    {
        const float2 offset = Random(id, count, 0).xy - 0.5f;
        const float3 target = pixel0 +
            (id.x + offset.x) * pixelU +
            (id.y + offset.y) * pixelV;
        Ray ray;
        for (uint i = 0; i < 10; i++)
        {
            ray.Origin.xy = Random(id, count, i).xy;
            if (dot(ray.Origin.xy, ray.Origin.xy) < 1.0f)
            {
                break;
            }
        }
        ray.Origin = SOURCE +
            (ray.Origin.x * vectorU * oof) +
            (ray.Origin.y * vectorV * oof);
        ray.Direction = target - ray.Origin;
        float3 attenuation = 1.0f;
        for (uint depth = 0; depth < DEPTH; depth++)
        {
            Hit hit;
            float near = 0.001f;
            float far = 1000000.0f;
            bool status = false;
            for (uint i = 0; i < NumSpheres; i++)
            {
                if (HitSphere(spheres[i], ray, near, far, hit))
                {
                    status = true;
                    far = hit.Offset;
                }
            }
            if (!status)
            {
                const float y = normalize(ray.Direction).y * 0.5f + 0.5f;
                const float3 colour = (1.0f - y) * HORIZON + y * SKY;
                attenuation *= colour;
                break;
            }
            float3 bounce;
            float3 colour;
            if (!GetBounce(ray, hit, id, count, depth, bounce, colour))
            {
                attenuation = 0.0f;
                break;
            }
            ray.Origin = hit.Position;
            ray.Direction = bounce;
            attenuation *= colour;
        }
        colour += attenuation;
    }
    if (bool(Batch))
    {
        colour += image1[id.xy].xyz;
    }
    const float3 curr = sqrt(colour / ((Batch + 1) * samples));
    if (Batch == BATCHES - 1)
    {
        colour = sqrt(colour / SAMPLES);
    }
    image1[id.xy] = float4(colour, 1.0f);
    image2[id.xy] = float4(curr, 1.0f);
}